/*
 *    Copyright 2015 West Coast Informatics, LLC
 */
package com.wci.umls.server.jpa.algo.insert;

import java.io.File;
import java.util.Date;
import java.util.List;
import java.util.Properties;
import java.util.UUID;

import com.wci.umls.server.AlgorithmParameter;
import com.wci.umls.server.ValidationResult;
import com.wci.umls.server.helpers.Branch;
import com.wci.umls.server.helpers.CancelException;
import com.wci.umls.server.helpers.ConfigUtility;
import com.wci.umls.server.helpers.FieldedStringTokenizer;
import com.wci.umls.server.jpa.ValidationResultJpa;
import com.wci.umls.server.jpa.algo.AbstractSourceLoaderAlgorithm;
import com.wci.umls.server.jpa.content.AbstractComponentHasAttributes;
import com.wci.umls.server.jpa.content.AttributeJpa;
import com.wci.umls.server.jpa.content.ConceptJpa;
import com.wci.umls.server.jpa.content.DefinitionJpa;
import com.wci.umls.server.model.content.Attribute;
import com.wci.umls.server.model.content.ComponentHasDefinitions;
import com.wci.umls.server.model.content.Definition;
import com.wci.umls.server.model.meta.IdType;
import com.wci.umls.server.model.meta.Terminology;
import com.wci.umls.server.services.RootService;
import com.wci.umls.server.services.handlers.IdentifierAssignmentHandler;

/**
 * Implementation of an algorithm to import attributes.
 */
public class AttributeLoaderAlgorithm extends AbstractSourceLoaderAlgorithm {

  /**
   * Instantiates an empty {@link AttributeLoaderAlgorithm}.
   * @throws Exception if anything goes wrong
   */
  public AttributeLoaderAlgorithm() throws Exception {
    super();
    setActivityId(UUID.randomUUID().toString());
    setWorkId("ATTRIBUTELOADER");
    setLastModifiedBy("admin");
  }

  /**
   * Check preconditions.
   *
   * @return the validation result
   * @throws Exception the exception
   */
  /* see superclass */
  @Override
  public ValidationResult checkPreconditions() throws Exception {

    ValidationResult validationResult = new ValidationResultJpa();

    if (getProject() == null) {
      throw new Exception("Attribute Loading requires a project to be set");
    }

    // Check the input directories

    String srcFullPath =
        ConfigUtility.getConfigProperties().getProperty("source.data.dir")
            + File.separator + getProcess().getInputPath();

    setSrcDirFile(new File(srcFullPath));
    if (!getSrcDirFile().exists()) {
      throw new Exception("Specified input directory does not exist");
    }

    return validationResult;
  }

  /**
   * Compute.
   *
   * @throws Exception the exception
   */
  /* see superclass */
  @Override
  public void compute() throws Exception {
    logInfo("Starting ATTRIBUTELOADING");

    // No molecular actions will be generated by this algorithm
    setMolecularActionFlag(false);

    // Set up the handler for identifier assignment
    final IdentifierAssignmentHandler handler =
        newIdentifierAssignmentHandler(getProject().getTerminology());
    handler.setTransactionPerOperation(false);
    handler.beginTransaction();

    // Count number of added and updated Attributes and Definitions
    // for logging
    int attributeAddCount = 0;
    int attributeUpdateCount = 0;
    int definitionAddCount = 0;
    int definitionUpdateCount = 0;

    try {

      logInfo(
          "[AttributeLoader] Checking for new/updated Attributes and Definitions");

      //
      // Load the attributes.src file, skipping SEMANTIC_TYPE, CONTEXT,
      // SUBSET_MEMBER, XMAP, XMAPTO, XMAPFROM
      //
      List<String> lines = loadFileIntoStringList(getSrcDirFile(), "attributes.src",
          null,
          "(.*)(SEMANTIC_TYPE|CONTEXT|SUBSET_MEMBER|XMAP|XMAPTO|XMAPFROM)(.*)");

      // Set the number of steps to the number of lines to be processed
      setSteps(lines.size());

      String fields[] = new String[14];

      // Each line of relationships.src corresponds to one relationship.
      // Check to make sure the relationship doesn't already exist in the
      // database
      // If it does, skip it.
      // If it does not, add it.
      for (String line : lines) {

        // Check for a cancelled call once every 100 relationships (doing it
        // every time
        // makes things too slow)
        if (getStepsCompleted() % 100 == 0 && isCancelled()) {
          throw new CancelException("Cancelled");
        }

        FieldedStringTokenizer.split(line, "|", 14, fields);

        // Fields:
        // 0 source_attribute_id
        // 1 sg_id
        // 2 attribute_level
        // 3 attribute_name
        // 4 attribute_value
        // 5 source
        // 6 status
        // 7 tobereleased
        // 8 released
        // 9 suppressible
        // 10 sg_type_1
        // 11 sg_qualifier_1
        // 12 source_atui
        // 13 hashcode

        // e.g.
        // 49|C47666|S|Chemical_Formula|C19H32N2O5.C4H11N|NCI_2016_05E|R|Y|N|N|SOURCE_CUI|NCI_2016_05E||875b4a03f8dedd9de05d6e9e4a440401|

        Terminology terminology = getCachedTerminology(fields[11]);
        if (terminology == null) {
          logWarnAndUpdate(line, "Warning - terminology not found: " + fields[11] + ".");
          continue;
        }

        // If it's a DEFITION, process the line as a definition instead of an
        // attribute
        if (fields[4].equals("DEFINITION")) {
          // Create the definition
          Definition newDefinition = new DefinitionJpa();
          newDefinition.setBranch(Branch.ROOT);
          newDefinition.setName(fields[3]);
          newDefinition.setValue(fields[4]);
          // TODO question - set to blank?
          newDefinition.setTerminologyId("TestId");
          newDefinition.setTerminology(terminology.getTerminology());
          newDefinition.setVersion(terminology.getVersion());
          newDefinition.setTimestamp(new Date());
          newDefinition.setSuppressible(fields[9].toUpperCase().equals("Y"));
          newDefinition.setPublished(fields[6].toUpperCase().equals("Y"));
          newDefinition.setPublishable(fields[7].toUpperCase().equals("Y"));
          newDefinition.setObsolete(false);

          // Load the containing object
          final String containerTerminologyId = fields[1];
          final String containerTerminology = terminology.getTerminology();
          final IdType containerIdType =
              lookupIdType(fields[10]);

          Long containerComponentId = null;
          if (containerIdType.equals(IdType.CONCEPT)) {
            containerComponentId = getId(containerIdType, containerTerminology,
                containerTerminologyId);
          } else {
            logWarnAndUpdate(line, "Warning - unsupported container class identified: "
                + containerIdType + ".");
            continue;
          }

          final ComponentHasDefinitions containerComponent =
              containerComponentId == null ? null
                  : (ComponentHasDefinitions) getComponent(containerComponentId,
                      lookupClass(containerIdType));

          if (containerComponent == null) {
            logWarnAndUpdate(line, "Warning - container component not found: "
                + containerComponentId + ", " + containerIdType
                + ".");
            continue;
          }

          // Compute definition identity
          String newDefinitionAtui =
              handler.getTerminologyId(newDefinition, containerComponent);

          // Check to see if attribute with matching ATUI already exists in the
          // database
          Long oldDefinitionId = getId(IdType.DEFINITION, newDefinitionAtui,
              newDefinition.getTerminology());

          // If no definition with the same ATUI exists, create this new
          // definition, and add it to its containing component
          if (oldDefinitionId == null) {
            // TODO - do this?
            newDefinition.getAlternateTerminologyIds()
                .put(getProject().getTerminology() + "-SRC", newDefinitionAtui);
            newDefinition = addDefinition(newDefinition, containerComponent);

            definitionAddCount++;
            putId(IdType.DEFINITION, newDefinitionAtui,
                newDefinition.getTerminology(), newDefinition.getId());

            // Add the definition to component
            containerComponent.getDefinitions().add(newDefinition);
            // TODO question: better way to handle this?
            if (containerIdType.equals(IdType.CONCEPT)) {
              updateComponent((ConceptJpa) containerComponent);
            } else {
              logWarnAndUpdate(line, "Warning - Unhandled class type: "
                  + containerComponent.getClass()
                  + ".");
              continue;
            }
          }
          // If a previous definition with same ATUI exists, load that object.
          else {
            final Definition oldDefinition = getDefinition(oldDefinitionId);

            boolean oldDefinitionChanged = false;

            // TODO question - this?
            // Create an "alternateTerminologyId" for the definition
            oldDefinition.getAlternateTerminologyIds()
                .put(getProject().getTerminology() + "-SRC", newDefinitionAtui);

            // Update the version
            if (!oldDefinition.getVersion()
                .equals(newDefinition.getVersion())) {
              oldDefinition.setVersion(newDefinition.getVersion());
              oldDefinitionChanged = true;
            }

            // If the existing definition doesn't exactly equal the new one,
            // update obsolete, and suppressible
            if (!oldDefinition.equals(newDefinition)) {
              if (oldDefinition.isObsolete() != newDefinition.isObsolete()) {
                oldDefinition.setObsolete(newDefinition.isObsolete());
                oldDefinitionChanged = true;
              }
              if (oldDefinition.isSuppressible() != newDefinition
                  .isSuppressible()) {
                oldDefinition.setSuppressible(newDefinition.isSuppressible());
                oldDefinitionChanged = true;
              }
            }

            if (oldDefinitionChanged) {
              updateDefinition(oldDefinition, containerComponent);
              definitionUpdateCount++;
            }
          }

        }

        // Otherwise, process the line as an attribute
        else {
          // Create the attribute
          Attribute newAttribute = new AttributeJpa();
          newAttribute.setBranch(Branch.ROOT);
          newAttribute.setName(fields[3]);
          newAttribute.setValue(fields[4]);
          // TODO question - set to blank?
          newAttribute.setTerminologyId("TestId");
          newAttribute.setTerminology(terminology.getTerminology());
          newAttribute.setVersion(terminology.getVersion());
          newAttribute.setTimestamp(new Date());
          newAttribute.setSuppressible(fields[9].toUpperCase().equals("Y"));
          newAttribute.setPublished(fields[6].toUpperCase().equals("Y"));
          newAttribute.setPublishable(fields[7].toUpperCase().equals("Y"));
          newAttribute.setObsolete(false);

          // Load the containing object
          final String containerTerminologyId = fields[1];
          final String containerTerminology = terminology.getTerminology();
          final IdType containerIdType =
              lookupIdType(fields[10]);

          Long containerComponentId = null;
          if (containerIdType.equals(IdType.CONCEPT)) {
            containerComponentId = getId(containerIdType,
                containerTerminologyId, containerTerminology);
          } else {
            logWarnAndUpdate(line,
                "Warning - unsupported container class identified: "
                    + containerIdType + ".");
            continue;
          }

          final AbstractComponentHasAttributes containerComponent =
              containerComponentId == null ? null
                  : (AbstractComponentHasAttributes) getComponent(
                      containerComponentId, lookupClass(containerIdType));

          if (containerComponent == null) {
            logWarnAndUpdate(line,
                "Warning - container component not found: "
                    + containerComponentId + ", " + containerIdType
                    + ".");
            continue;
          }

          // Compute attribute identity
          String newAttributeAtui =
              handler.getTerminologyId(newAttribute, containerComponent);

          // Check to see if attribute with matching ATUI already exists in the
          // database
          Long oldAttributeId = getId(IdType.ATTRIBUTE, newAttributeAtui,
              newAttribute.getTerminology());

          // If no attribute with the same ATUI exists, create this new
          // Attribute, and add it to its containing component
          if (oldAttributeId == null) {
            // TODO - do this?
            newAttribute.getAlternateTerminologyIds()
                .put(getProject().getTerminology() + "-SRC", newAttributeAtui);
            newAttribute = addAttribute(newAttribute, containerComponent);

            attributeAddCount++;
            putId(IdType.ATTRIBUTE, newAttributeAtui,
                newAttribute.getTerminology(), newAttribute.getId());

            // Add the attribute to component
            containerComponent.getAttributes().add(newAttribute);
            // TODO question: better way to handle this?
            if (containerIdType.equals(IdType.CONCEPT)) {
              updateComponent((ConceptJpa) containerComponent);
            } else {        
              logWarnAndUpdate(line,
                  "Warning - Unhandled class type: "
                      + containerComponent.getClass()
                      + ".");
              continue;
            }

          }
          // If a previous attribute with same ATUI exists, load that object.
          else {
            final Attribute oldAttribute = getAttribute(oldAttributeId);

            boolean oldAttributeChanged = false;

            // TODO question - this?
            // Create an "alternateTerminologyId" for the attribute
            oldAttribute.getAlternateTerminologyIds()
                .put(getProject().getTerminology() + "-SRC", newAttributeAtui);

            // Update the version
            if (!oldAttribute.getVersion().equals(newAttribute.getVersion())) {
              oldAttribute.setVersion(newAttribute.getVersion());
              oldAttributeChanged = true;
            }

            // If the existing relationship doesn't exactly equal the new one,
            // update obsolete, and suppressible
            if (!oldAttribute.equals(newAttribute)) {
              if (oldAttribute.isObsolete() != newAttribute.isObsolete()) {
                oldAttribute.setObsolete(newAttribute.isObsolete());
                oldAttributeChanged = true;
              }
              if (oldAttribute.isSuppressible() != newAttribute
                  .isSuppressible()) {
                oldAttribute.setSuppressible(newAttribute.isSuppressible());
                oldAttributeChanged = true;
              }
            }

            if (oldAttributeChanged) {
              updateAttribute(oldAttribute, containerComponent);
              attributeUpdateCount++;
            }
          }
        }

        // Update the progress
        updateProgress();

        handler.logAndCommit(
            "[Attribute Loader] Attribute identities processed ",
            getStepsCompleted(), RootService.logCt, RootService.commitCt);
      }

      commitClearBegin();
      handler.commitClearBegin();

      logInfo(
          "[AttributeLoader] Added " + attributeAddCount + " new Attributes.");
      logInfo("[AttributeLoader] Updated " + attributeUpdateCount
          + " existing Attributes.");
      logInfo("[AttributeLoader] Added " + definitionAddCount
          + " new Definitions.");
      logInfo("[AttributeLoader] Updated " + definitionUpdateCount
          + " existing Definitions.");

      logInfo("  project = " + getProject().getId());
      logInfo("  workId = " + getWorkId());
      logInfo("  activityId = " + getActivityId());
      logInfo("  user  = " + getLastModifiedBy());
      logInfo("Finished ATTRIBUTELOADING");

    } catch (

    Exception e) {
      logError("Unexpected problem - " + e.getMessage());
      throw e;
    }

  }

  /**
   * Reset.
   *
   * @throws Exception the exception
   */
  /* see superclass */
  @Override
  public void reset() throws Exception {
    // n/a - No reset
  }

  /**
   * Sets the properties.
   *
   * @param p the properties
   * @throws Exception the exception
   */
  /* see superclass */
  @Override
  public void setProperties(Properties p) throws Exception {
    checkRequiredProperties(new String[] {
        // TODO - handle problem with config.properties needing properties
    }, p);

  }

  /**
   * Returns the parameters.
   *
   * @return the parameters
   */
  /* see superclass */
  @Override
  public List<AlgorithmParameter> getParameters() {
    final List<AlgorithmParameter> params = super.getParameters();

    return params;
  }

}
/*
 *    Copyright 2015 West Coast Informatics, LLC
 */
package com.wci.umls.server.jpa.algo.insert;

import java.io.File;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.UUID;

import com.wci.umls.server.AlgorithmParameter;
import com.wci.umls.server.ValidationResult;
import com.wci.umls.server.helpers.Branch;
import com.wci.umls.server.helpers.CancelException;
import com.wci.umls.server.helpers.ConfigUtility;
import com.wci.umls.server.helpers.FieldedStringTokenizer;
import com.wci.umls.server.jpa.ValidationResultJpa;
import com.wci.umls.server.jpa.algo.AbstractSourceLoaderAlgorithm;
import com.wci.umls.server.jpa.content.AtomJpa;
import com.wci.umls.server.jpa.content.CodeJpa;
import com.wci.umls.server.jpa.content.ConceptJpa;
import com.wci.umls.server.jpa.content.DescriptorJpa;
import com.wci.umls.server.jpa.content.LexicalClassJpa;
import com.wci.umls.server.jpa.content.StringClassJpa;
import com.wci.umls.server.model.content.Atom;
import com.wci.umls.server.model.content.Code;
import com.wci.umls.server.model.content.Concept;
import com.wci.umls.server.model.content.Descriptor;
import com.wci.umls.server.model.content.LexicalClass;
import com.wci.umls.server.model.content.StringClass;
import com.wci.umls.server.model.meta.TermType;
import com.wci.umls.server.model.meta.Terminology;
import com.wci.umls.server.model.workflow.WorkflowStatus;
import com.wci.umls.server.services.RootService;
import com.wci.umls.server.services.handlers.IdentifierAssignmentHandler;

/**
 * Implementation of an algorithm to import atoms.
 */
public class AtomLoaderAlgorithm extends AbstractSourceLoaderAlgorithm {

  /** The full directory where the src files are. */
  private File srcDirFile = null;

  /** The previous progress. */
  private int previousProgress;

  /** The steps. */
  private int steps;

  /** The steps completed. */
  private int stepsCompleted;

  /**
   * Instantiates an empty {@link AtomLoaderAlgorithm}.
   * @throws Exception if anything goes wrong
   */
  public AtomLoaderAlgorithm() throws Exception {
    super();
    setActivityId(UUID.randomUUID().toString());
    setWorkId("ATOMLOADER");
    setLastModifiedBy("admin");
  }

  /**
   * Check preconditions.
   *
   * @return the validation result
   * @throws Exception the exception
   */
  /* see superclass */
  @Override
  public ValidationResult checkPreconditions() throws Exception {

    ValidationResult validationResult = new ValidationResultJpa();

    if (getProject() == null) {
      throw new Exception("Atom Loading requires a project to be set");
    }

    // Check the input directories

    String srcFullPath =
        ConfigUtility.getConfigProperties().getProperty("source.data.dir")
            + File.separator + getProcess().getInputPath();

    srcDirFile = new File(srcFullPath);
    if (!srcDirFile.exists()) {
      throw new Exception("Specified input directory does not exist");
    }

    return validationResult;
  }

  /**
   * Compute.
   *
   * @throws Exception the exception
   */
  /* see superclass */
  @Override
  public void compute() throws Exception {
    logInfo("Starting ATOMLOADING");

    // No molecular actions will be generated by this algorithm
    setMolecularActionFlag(false);

    // Set up the handler for identifier assignment
    final IdentifierAssignmentHandler handler =
        newIdentifierAssignmentHandler(getProject().getTerminology());
    handler.setTransactionPerOperation(false);
    handler.beginTransaction();

    // Count number of added and updated Atoms, for logging
    int addCount = 0;
    int updateCount = 0;

    try {

      //
      // Load the classes_atoms.src file
      //
      List<String> lines =
          loadFileIntoStringList(srcDirFile, "classes_atoms.src", null, null);

      logInfo("[AtomLoader] Checking for new/updated Atoms");

      // Set the number of steps to the number of atoms to be processed
      steps = lines.size();

      previousProgress = 0;
      stepsCompleted = 0;

      String fields[] = new String[15];

      // Each line of classes_atoms.src corresponds to one atom.
      // Check to make sure the atom doesn't already exist in the database
      // If it does, skip it.
      // If it does not, add it.
      for (String line : lines) {

        // Check for a cancelled call once every 100 lines
        if (stepsCompleted % 100 == 0) {
          if (isCancelled()) {
            throw new CancelException("Cancelled");
          }
        }

        FieldedStringTokenizer.split(line, "|", 15, fields);

        // Fields:
        // 0 src_atom_id (Atom.alternateTerminologlyId(), where Key =
        // ProjectTerminology + "-SRC")
        // 1 source (Atom.terminology, Atom.version)
        // 2 termgroup (Atom.termType (portion after the forward-slash))
        // 3 code (Atom.codeId)
        // 4 status (Atom.WorkflowStatus)
        // 5 tobereleased (Atom.publishable)
        // 6 released (Atom.published)
        // 7 atom_name (Atom.name)
        // 8 suppressible (Atom.suppresible, Atom.obsolete)
        // obsolete = true IFF "O".
        // suppresible = true IFF "O, Y, E";
        // 9 source_aui (Atom.terminologyId)
        // 10 source_cui (Atom.conceptId)
        // 11 source_dui (Atom.descriptorId)
        // 12 language (Atom.language)
        // 13 order_id (Atom.alternateTerminologlyId(), where Key =
        // ProjectTerminology + "-ORDER")
        // 14 last_release_cui (Atom.conceptTerminologyId(), where
        // Key=ProjectTerminology)

        // e.g.
        // 362166319|NCI_2016_05E|NCI_2016_05E/PT|C28777|R|Y|N|1,9-Nonanediol|N||
        // C28777||ENG|362166319|

        //
        // Atom based on input line.
        //
        Atom newAtom = new AtomJpa();
        if (!ConfigUtility.isEmpty(fields[0])) {
          newAtom.getAlternateTerminologyIds()
              .put(getProject().getTerminology() + "-SRC", fields[0]);
        }
        Terminology term = getCachedTerminology(fields[1]);
        if (term == null) {
          logWarn("Warning - terminology not found: " + fields[1]
              + ". Could not process the following line:\n\t" + line);
          updateProgress();
          logAndCommit("[Atom Loader] Atoms processed ", stepsCompleted,
              RootService.logCt, RootService.commitCt);
          continue;
        } else {
          newAtom.setTerminology(term.getTerminology());
          newAtom.setVersion(term.getVersion());
        }
        newAtom.setTermType(fields[2].substring(fields[2].indexOf("/") + 1));
        newAtom.setCodeId(fields[3]);
        if (fields[4].equals("N")) {
          newAtom.setWorkflowStatus(WorkflowStatus.NEEDS_REVIEW);
        }
        if (fields[4].equals("R")) {
          newAtom.setWorkflowStatus(WorkflowStatus.READY_FOR_PUBLICATION);
        }
        newAtom
            .setPublishable((fields[5].equals("Y") || fields[5].equals("y")));
        newAtom.setPublished((fields[6].equals("Y")));
        newAtom.setName(fields[7]);
        newAtom.setSuppressible((fields[8].equals("Y")));
        newAtom.setObsolete("OYE".contains(fields[8]));
        newAtom.setTerminologyId(fields[9]);
        newAtom.setConceptId(fields[10]);
        newAtom.setDescriptorId(fields[11]);
        newAtom.setLanguage(fields[12]);
        if (!ConfigUtility.isEmpty(fields[13])) {
          newAtom.getAlternateTerminologyIds()
              .put(getProject().getTerminology() + "-ORDER", fields[13]);
        }
        if (!ConfigUtility.isEmpty(fields[14])) {
          newAtom.getConceptTerminologyIds().put(getProject().getTerminology(),
              fields[14]);
        }

        // Add string and lexical classes to get assign their Ids
        final StringClass strClass = new StringClassJpa();
        strClass.setLanguage(newAtom.getLanguage());
        strClass.setName(newAtom.getName());
        newAtom.setStringClassId(handler.getTerminologyId(strClass));

        // Get normalization handler
        final LexicalClass lexClass = new LexicalClassJpa();
        lexClass.setLanguage(newAtom.getLanguage());
        lexClass.setNormalizedName(getNormalizedString(newAtom.getName()));
        newAtom.setLexicalClassId(handler.getTerminologyId(lexClass));

        // Compute atom identity
        String newAtomAui = handler.getTerminologyId(newAtom);

        // Check to see if atom with matching AUI already exists in the database
        Long oldAtomId =
            getId(AtomJpa.class, newAtomAui, newAtom.getTerminology());

        // If no atom with the same AUI exists, add this new Atom and a concept
        // to put it into.
        if (oldAtomId == null) {
          newAtom.getAlternateTerminologyIds()
              .put(getProject().getTerminology(), newAtomAui);
          newAtom = addAtom(newAtom);

          // Create a new concept to store the atom
          Concept newConcept = new ConceptJpa();
          newConcept.setTerminology(getProject().getTerminology());
          newConcept.setTerminologyId("");
          newConcept.setVersion(getProject().getVersion());
          newConcept.setObsolete(newAtom.isObsolete());
          newConcept.setSuppressible(newAtom.isSuppressible());
          newConcept.setPublishable(newAtom.isPublishable());
          newConcept.setPublished(newAtom.isPublished());
          newConcept.getAtoms().add(newAtom);
          newConcept.setName(newAtom.getName());
          newConcept.setWorkflowStatus(WorkflowStatus.NEEDS_REVIEW);
          newConcept = addConcept(newConcept);

          // Set the terminology Id
          newConcept.setTerminologyId(newConcept.getId().toString());
          updateConcept(newConcept);

          addCount++;
          putId(AtomJpa.class, newAtom.getTerminology(), newAtomAui,
              newAtom.getId());

          // Reconcile code/concept/descriptor
          reconcileCodeConceptDescriptor(newAtom);

        }
        // If a previous atom with same AUI exists, load that object.
        else {
          final Atom oldAtom = getAtom(oldAtomId);

          boolean oldAtomChanged = false;

          // Update "alternateTerminologyIds"
          final Map<String, String> altTermIds =
              oldAtom.getAlternateTerminologyIds();
          if (!altTermIds.containsKey(getProject().getTerminology() + "-SRC")) {
            oldAtom.getAlternateTerminologyIds()
                .put(getProject().getTerminology() + "-SRC", fields[0]);
            oldAtomChanged = true;
          }
          if (!altTermIds
              .containsKey(getProject().getTerminology() + "-ORDER")) {
            oldAtom.getAlternateTerminologyIds()
                .put(getProject().getTerminology() + "-ORDER", fields[13]);
            oldAtomChanged = true;
          }

          // Update the version
          if (!oldAtom.getVersion().equals(newAtom.getVersion())) {
            oldAtom.setVersion(newAtom.getVersion());
            oldAtomChanged = true;
          }

          // If this loaded Atom is not exactly the same as the new Atom:
          if (!oldAtom.equals(newAtom)) {

            // Update obsolete and suppresible.
            // If the old version of the atom is suppresible, and its term type
            // is not, keep the old atom's suppresibility. Otherwise, use the
            // new Atom's suppresible value.
            TermType atomTty = getCachedTermType(oldAtom.getTermType());
            if (oldAtom.isSuppressible() != newAtom.isSuppressible()
                && !(oldAtom.isSuppressible() && !atomTty.isSuppressible())) {
              oldAtom.setSuppressible(newAtom.isSuppressible());
              oldAtomChanged = true;
            }
            if (oldAtom.isObsolete() != newAtom.isObsolete()
                && !(oldAtom.isObsolete() && !atomTty.isObsolete())) {
              oldAtom.setObsolete(newAtom.isObsolete());
              oldAtomChanged = true;
            }
          }

          if (oldAtomChanged) {
            updateAtom(oldAtom);
            updateCount++;
          }

          // Reconcile code/concept/descriptor
          reconcileCodeConceptDescriptor(oldAtom);
        }

        // Update the progress
        updateProgress();

        logAndCommit("[Atom Loader] Atoms processed ", stepsCompleted,
            RootService.logCt, RootService.commitCt);
        handler.logAndCommit("[Atom Loader] Atom identities processed ",
            stepsCompleted, RootService.logCt, RootService.commitCt);

      }

      commitClearBegin();
      handler.commitClearBegin();

      logInfo("[AtomLoader] Added " + addCount + " new Atoms.");
      logInfo("[AtomLoader] Updated " + updateCount + " existing Atoms.");

      logInfo("  project = " + getProject().getId());
      logInfo("  workId = " + getWorkId());
      logInfo("  activityId = " + getActivityId());
      logInfo("  user  = " + getLastModifiedBy());
      logInfo("Finished ATOMLOADING");

    } catch (Exception e) {
      logError("Unexpected problem - " + e.getMessage());
      throw e;
    }

  }

  /**
   * Reconcile code concept descriptor.
   *
   * @param atom the atom
   * @throws Exception the exception
   */
  private void reconcileCodeConceptDescriptor(Atom atom) throws Exception {
    // Check map to see if code already exists
    if (!atom.getCodeId().isEmpty()) {

      Long existingCodeId =
          getId(CodeJpa.class, atom.getCodeId(), atom.getTerminology());
      if (existingCodeId != null) {
        final Code code = getCode(existingCodeId);
        code.getAtoms().add(atom);
        code.setVersion(atom.getVersion());
        updateCode(code);
      }

      // else create a new code
      else {
        final Code code = new CodeJpa();
        code.setTerminology(atom.getTerminology());
        code.setTerminologyId(atom.getCodeId());
        code.setVersion(atom.getVersion());
        code.setBranch(Branch.ROOT);
        code.setName(atom.getName());
        code.setObsolete(false);
        code.setPublished(false);
        code.setPublishable(true);
        code.setSuppressible(false);
        code.setWorkflowStatus(atom.getWorkflowStatus());

        code.getAtoms().add(atom);
        addCode(code);
        putId(CodeJpa.class, code.getTerminologyId(), code.getTerminology(),
            code.getId());
      }
    }

    // Check map to see if concept already exists
    if (!atom.getConceptId().isEmpty()) {

      Long existingConceptId =
          getId(ConceptJpa.class, atom.getConceptId(), atom.getTerminology());
      if (existingConceptId != null) {
        // final Concept concept = new ConceptJpa(getConcept(existingConceptId),
        // true);
        final Concept concept = getConcept(existingConceptId);
        concept.getAtoms().add(atom);
        concept.setVersion(atom.getVersion());
        updateConcept(concept);
      }

      // else create a new concept
      else {
        final Concept concept = new ConceptJpa();
        concept.setTerminology(atom.getTerminology());
        concept.setTerminologyId(atom.getConceptId());
        concept.setVersion(atom.getVersion());
        concept.setBranch(Branch.ROOT);
        concept.setName(atom.getName());
        concept.setObsolete(false);
        concept.setPublished(false);
        concept.setPublishable(true);
        concept.setSuppressible(false);
        concept.setWorkflowStatus(atom.getWorkflowStatus());

        concept.getAtoms().add(atom);
        addConcept(concept);
        putId(ConceptJpa.class, concept.getTerminologyId(),
            concept.getTerminology(), concept.getId());
      }
    }
    // Check map to see if descriptor already exists
    if (!atom.getDescriptorId().isEmpty()) {

      Long existingDescriptorId = getId(DescriptorJpa.class,
          atom.getDescriptorId(), atom.getTerminology());
      if (existingDescriptorId != null) {
        final Descriptor descriptor = getDescriptor(existingDescriptorId);
        descriptor.getAtoms().add(atom);
        descriptor.setVersion(atom.getVersion());
        updateDescriptor(descriptor);
      }

      // else create a new descriptor
      else {
        final Descriptor descriptor = new DescriptorJpa();
        descriptor.setTerminology(atom.getTerminology());
        descriptor.setTerminologyId(atom.getDescriptorId());
        descriptor.setVersion(atom.getVersion());
        descriptor.setBranch(Branch.ROOT);
        descriptor.setName(atom.getName());
        descriptor.setObsolete(false);
        descriptor.setPublished(false);
        descriptor.setPublishable(true);
        descriptor.setSuppressible(false);
        descriptor.setWorkflowStatus(atom.getWorkflowStatus());

        descriptor.getAtoms().add(atom);
        addDescriptor(descriptor);
        putId(DescriptorJpa.class, descriptor.getTerminologyId(),
            descriptor.getTerminology(), descriptor.getId());
      }
    }
  }

  /**
   * Reset.
   *
   * @throws Exception the exception
   */
  /* see superclass */
  @Override
  public void reset() throws Exception {
    // n/a - No reset
  }

  /**
   * Update progress.
   *
   * @throws Exception the exception
   */
  public void updateProgress() throws Exception {
    stepsCompleted++;
    int currentProgress = (int) ((100.0 * stepsCompleted / steps));
    if (currentProgress > previousProgress) {
      fireProgressEvent(currentProgress,
          "ATOMLOADING progress: " + currentProgress + "%");
      previousProgress = currentProgress;
    }
  }

  /**
   * Sets the properties.
   *
   * @param p the properties
   * @throws Exception the exception
   */
  /* see superclass */
  @Override
  public void setProperties(Properties p) throws Exception {
    checkRequiredProperties(new String[] {
        // TODO - handle problem with config.properties needing properties
    }, p);

  }

  /**
   * Returns the parameters.
   *
   * @return the parameters
   */
  /* see superclass */
  @Override
  public List<AlgorithmParameter> getParameters() {
    final List<AlgorithmParameter> params = super.getParameters();
    return params;
  }

}
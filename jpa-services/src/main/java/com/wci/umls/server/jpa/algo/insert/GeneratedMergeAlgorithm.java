/*
 *    Copyright 2015 West Coast Informatics, LLC
 */
package com.wci.umls.server.jpa.algo.insert;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

import org.apache.log4j.Logger;

import com.wci.umls.server.AlgorithmParameter;
import com.wci.umls.server.ValidationResult;
import com.wci.umls.server.helpers.KeyValuePair;
import com.wci.umls.server.helpers.LocalException;
import com.wci.umls.server.helpers.PfsParameter;
import com.wci.umls.server.helpers.QueryType;
import com.wci.umls.server.helpers.SearchResult;
import com.wci.umls.server.helpers.SearchResultList;
import com.wci.umls.server.jpa.AlgorithmParameterJpa;
import com.wci.umls.server.jpa.ValidationResultJpa;
import com.wci.umls.server.jpa.algo.AbstractMergeAlgorithm;
import com.wci.umls.server.jpa.helpers.PfsParameterJpa;
import com.wci.umls.server.model.content.Atom;
import com.wci.umls.server.model.content.Concept;

/**
 * Implementation of an algorithm to import attributes.
 */
public class GeneratedMergeAlgorithm extends AbstractMergeAlgorithm {

  /** The query type. */
  private QueryType queryType;

  /** The query. */
  private String query;

  /** The check names. */
  private List<String> checkNames;

  /** The new atoms only filter. */
  private Boolean newAtomsOnly = null;

  /** The filter query type. */
  private QueryType filterQueryType;

  /** The filter query. */
  private String filterQuery;

  /** The make demotions. */
  private Boolean makeDemotions = null;

  /** The change status. */
  private Boolean changeStatus = null;

  /** The merge set. */
  private String mergeSet;

  /**
   * Instantiates an empty {@link GeneratedMergeAlgorithm}.
   * @throws Exception if anything goes wrong
   */
  public GeneratedMergeAlgorithm() throws Exception {
    super();
    setActivityId(UUID.randomUUID().toString());
    setWorkId("PRECOMPUTEDMERGE");
    setLastModifiedBy("admin");
  }

  /**
   * Check preconditions.
   *
   * @return the validation result
   * @throws Exception the exception
   */
  /* see superclass */
  @Override
  public ValidationResult checkPreconditions() throws Exception {

    ValidationResult validationResult = new ValidationResultJpa();

    if (getProject() == null) {
      throw new Exception("Precomputed Merge requires a project to be set");
    }

    return validationResult;
  }

  /**
   * Compute.
   *
   * @throws Exception the exception
   */
  /* see superclass */
  @Override
  public void compute() throws Exception {
    logInfo("Starting PRECOMPUTEDMERGE");

    // Molecular actions WILL be generated by this algorithm
    setMolecularActionFlag(true);

    // Count number of merges successfully and unsuccessfully performed
    int successfulMerges = 0;
    int unsuccessfulMerges = 0;

    // Generate parameters to pass into query executions
    Map<String, String> params = new HashMap<>();
    params.put("terminology", getTerminology());
    params.put("version", getVersion());
    params.put("projectTerminology", getProject().getVersion());

    // Execute query to get atom1,atom2 Id pairs
    List<Long[]> atomIdPairs = executeQuery(query, queryType, params);

    // Execute filter query
    // If JQL/SQL filter query, returns atom1,atom2 Id pairs
    if (filterQueryType == QueryType.SQL || filterQueryType == QueryType.JQL) {
      List<Long[]> filterAtomIdPairs =
          executeQuery(filterQuery, filterQueryType, params);
      // TODO - test to make sure .remove works, what with the array object
      // equivalence ballyhoo.
      // If filter pair exist in atomIdPairs in 1,2 or 2,1 order, remove that
      // pair
      for (Long[] filterAtomIdPair : filterAtomIdPairs) {
        if (filterAtomIdPairMatch(new ArrayList<Long[]>(atomIdPairs),
            filterAtomIdPair)) {
          atomIdPairs.remove(filterAtomIdPair);
        }

        // Also check for 2,1 order matches
        final Long[] inverseFilterAtomIdPair = new Long[] {
            filterAtomIdPair[1], filterAtomIdPair[0]
        };
        if (filterAtomIdPairMatch(new ArrayList<Long[]>(atomIdPairs),
            inverseFilterAtomIdPair)) {
          atomIdPairs.remove(inverseFilterAtomIdPair);
        }
      }
    }
    // If LUCENE filter query, returns concept id
    else if (filterQueryType == QueryType.LUCENE) {
      List<Long[]> filterConceptIds =
          executeQuery(filterQuery, filterQueryType, params);
      // For each returned concept, add its atoms' ids to a set
      final Set<Long> filterAtomIds = new HashSet<>();
      for (Long[] conceptId : filterConceptIds) {
        Concept c = getConcept(conceptId[0]);
        for (Atom a : c.getAtoms()) {
          filterAtomIds.add(a.getId());
        }
      }
      // TODO - test to make sure .remove works, what with the array object
      // equivalence ballyhoo.
      // For each atomID pair, if atomId1 is one of the Atoms contained in the
      // filter concepts, remove pair
      for (Long[] atomIdPair : new ArrayList<>(atomIdPairs)) {
        if (filterAtomIds.contains(atomIdPair[0])) {
          atomIdPairs.remove(atomIdPair);
        }
      }
    }
    // PROGRAM filter queries not supported yet
    else if (queryType == QueryType.PROGRAM) {
      throw new Exception("PROGRAM queries not yet supported");
    }

    // If new Atoms Only filter is selected, remove any pairs with old atoms
    if (newAtomsOnly) {
      Long maxAtomIdPreInsertion = null;
      if (getProcess().getExecutionInfo()
          .containsKey("maxAtomIdPreInsertion")) {
        maxAtomIdPreInsertion = Long.parseLong(
            getProcess().getExecutionInfo().get("maxAtomIdPreInsertion"));
      }
      if (maxAtomIdPreInsertion != null) {
        for (Long[] atomIdPair : new ArrayList<>(atomIdPairs)) {
          if (atomIdPair[0] <= maxAtomIdPreInsertion
              || atomIdPair[1] <= maxAtomIdPreInsertion) {
            atomIdPairs.remove(atomIdPair);
          }
        }
      }
    }

    // Calculate MergeLevel, and save it as third element of atomIdPair
    for (Long[] atomIdPair : atomIdPairs) {
      atomIdPair[2] = calculateMergeLevel(atomIdPair[0], atomIdPair[1]);
    }

    // Order atomIdPairs
    // sort by MergeLevel, atomId1, atomId2
    Collections.sort(atomIdPairs, new Comparator<Long[]>() {

      @Override
      public int compare(final Long[] atomPair1, final Long[] atomPair2) {
        int c = 0;
        c = atomPair1[2].compareTo(atomPair2[2]);
        if (c == 0)
          c = atomPair1[0].compareTo(atomPair2[0]);
        if (c == 0)
          c = atomPair1[1].compareTo(atomPair2[1]);

        return c;
      }
    });

    // Set the steps count to the number of atomPairs merges will be
    // attempted for
    setSteps(atomIdPairs.size());

    // Attempt to perform the merge given the integrity checks
    for (Long[] atomIdPair : atomIdPairs) {
      boolean mergeSuccess = merge(atomIdPair[0], atomIdPair[1], checkNames,
          makeDemotions, changeStatus, getProject());
      // Increment the counts based on success of merge attempt
      if (mergeSuccess) {
        successfulMerges++;
      } else {
        unsuccessfulMerges++;
      }

      // Update the progress
      updateProgress();
    }

    System.out.println("TESTTEST");

    commitClearBegin();

    logInfo("[GeneratedMerge] " + successfulMerges
        + " merges successfully performed.");
    logInfo("[GeneratedMerge] " + unsuccessfulMerges
        + " attempted merges were unsuccessful.");

    logInfo(" project = " + getProject().getId());
    logInfo(" workId = " + getWorkId());
    logInfo(" activityId = " + getActivityId());
    logInfo(" mergeSet = " + mergeSet);
    logInfo(" user = " + getLastModifiedBy());
    logInfo("Finished GENERATEDMERGE");
  }

  /**
   * Returns the merge level.
   * 
   * MergeLevel = 1 => atom1.code=atom2.code && atom1.sui=atom2.sui &&
   * atom1.tty=atom2.tty 2 => atom1.code=atom2.code && atom1.lui=atom2.lui &&
   * atom1.tty=atom2.tty 3 => atom1.code=atom2.code && atom1.sui=atom2.sui 4 =>
   * atom1.code=atom2.code && atom1.lui=atom2.lui 5 => atom1.code=atom2.code
   *
   * @param atomIdPair the atom id pair
   * @return the merge level
   * @throws Exception the exception
   */
  private Long calculateMergeLevel(Long atomId1, Long AtomId2)
    throws Exception {

    Long mergeLevel = null;
    Atom atom1 = getAtom(atomId1);
    Atom atom2 = getAtom(AtomId2);
    if (atom1.getCodeId().equals(atom2.getCodeId())
        && atom1.getStringClassId().equals(atom2.getStringClassId())
        && atom1.getTermType().equals(atom2.getTermType())) {
      mergeLevel = 1L;
    } else if (atom1.getCodeId().equals(atom2.getCodeId())
        && atom1.getLexicalClassId().equals(atom2.getLexicalClassId())
        && atom1.getTermType().equals(atom2.getTermType())) {
      mergeLevel = 2L;
    } else if (atom1.getCodeId().equals(atom2.getCodeId())
        && atom1.getStringClassId().equals(atom2.getStringClassId())) {
      mergeLevel = 3L;
    } else if (atom1.getCodeId().equals(atom2.getCodeId())
        && atom1.getLexicalClassId().equals(atom2.getLexicalClassId())) {
      mergeLevel = 4L;
    } else if (atom1.getCodeId().equals(atom2.getCodeId())) {
      mergeLevel = 5L;
    } else {
      mergeLevel = 6L; // TODO - check if this is true
    }

    return mergeLevel;
  }

  private boolean filterAtomIdPairMatch(List<Long[]> atomIdPairs,
    Long[] filterAtomIdPair) {
    // If filter pair exist in atomIdPairs, remove
    for (Long[] atomIdPair : new ArrayList<>(atomIdPairs)) {
      if (Arrays.equals(filterAtomIdPair, atomIdPair)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Execute query.
   *
   * @param query the query
   * @param queryType the query type
   * @param params the params
   * @return the list
   * @throws Exception the exception
   */
  @SuppressWarnings("unchecked")
  private List<Long[]> executeQuery(String query, QueryType queryType,
    Map<String, String> params) throws Exception {

    // Handle the LUCENE case
    if (queryType == QueryType.LUCENE) {
      final PfsParameter pfs = new PfsParameterJpa();
      pfs.setQueryRestriction(query);

      // Perform search
      final SearchResultList resultList = this
          .findConcepts(getProject().getTerminology(), null, null, null, pfs);
      // Cluster results
      final List<Long[]> results = new ArrayList<>();
      final Set<String> addedResults = new HashSet<>();
      for (final SearchResult concept : resultList.getObjects()) {
        final Long[] result = new Long[1];
        result[0] = concept.getId();
        // Duplicate check
        if (!addedResults.contains(concept.getId().toString())) {
          results.add(result);
          addedResults.add(concept.getId().toString());
        }
        results.add(result);
      }
      return results;
    }

    // Handle PROGRAM queries
    else if (queryType == QueryType.PROGRAM) {
      throw new Exception("PROGRAM queries not yet supported");
    }

    // Handle SQL and JQL queries here
    // Check for JQL/SQL errors
    // ensure that query begins with SELECT (i.e. prevent injection
    // problems)
    else if (queryType == QueryType.JQL || queryType == QueryType.SQL) {
      if (!query.toUpperCase().startsWith("SELECT")) {
        throw new LocalException(
            "Query has bad format:  does not begin with SELECT");
      }

      // check for multiple commands (i.e. multiple semi-colons)
      if (query.indexOf(";") != query.length() - 1 && query.endsWith(";")) {
        throw new LocalException(
            "Query has bad format:  multiple queries detected");
      }

      // crude check: check for data manipulation commands
      if (query.toUpperCase()
          .matches("ALTER |CREATE |DROP |DELETE |INSERT |TRUNCATE |UPDATE ")) {
        throw new LocalException("Query has bad format:  DDL request detected");
      }

      // check for proper format for insertion into reports

      if (query.toUpperCase().indexOf("FROM") == -1) {
        throw new LocalException("Query must contain the term FROM");
      }

      // Execute the query
      javax.persistence.Query jpaQuery = null;
      if (queryType == QueryType.SQL) {
        jpaQuery = this.getEntityManager().createNativeQuery(query);
      } else if (queryType == QueryType.JQL) {
        jpaQuery = this.getEntityManager().createQuery(query);
      } else {
        throw new Exception("Unsupported query type " + queryType);
      }
      // Handle special query key-words
      if (params != null) {
        for (final String key : params.keySet()) {
          if (query.contains(":" + key)) {
            jpaQuery.setParameter(key, params.get(key));
          }
        }
      }
      Logger.getLogger(getClass()).info("  query = " + query);

      // Return the result list as longs.
      final List<Object[]> list = jpaQuery.getResultList();
      final List<Long[]> results = new ArrayList<>();
      final Set<String> addedResults = new HashSet<>();
      for (final Object[] entry : list) {
        Long atomId1 = null;
        if (entry[0] instanceof BigInteger) {
          atomId1 = ((BigInteger) entry[0]).longValue();
        } else if (entry[0] instanceof Long) {
          atomId1 = (Long) entry[0];
        }
        Long atomId2 = null;
        if (entry[1] instanceof BigInteger) {
          atomId2 = ((BigInteger) entry[1]).longValue();
        } else if (entry[1] instanceof Long) {
          atomId2 = (Long) entry[1];
        }
        final Long[] result = new Long[] {
            atomId1, atomId2
        };
        // Duplicate check
        if (!addedResults.contains(atomId1 + "|" + atomId2)) {
          results.add(result);
          addedResults.add(atomId1 + "|" + atomId2);
        }
      }

      return results;
    }

    return null;

  }

  /**
   * Reset.
   *
   * @throws Exception the exception
   */
  /* see superclass */
  @Override
  public void reset() throws Exception {
    // n/a - No reset
  }

  /* see superclass */
  @Override
  public void checkProperties(Properties p) throws Exception {
    checkRequiredProperties(new String[] {
        "mergeSet", "queryType", "query", "checkNames"
    }, p);
  }

  /* see superclass */
  @Override
  public void setProperties(Properties p) throws Exception {

    if (p.getProperty("queryType") != null) {
      queryType = QueryType.valueOf(QueryType.class,
          String.valueOf(p.getProperty("queryType")));
    }
    if (p.getProperty("query") != null) {
      query = String.valueOf(p.getProperty("query"));
    }
    if (p.getProperty("checkNames") != null) {
      checkNames =
          Arrays.asList(String.valueOf(p.getProperty("checkNames")).split(";"));
    }
    if (p.getProperty("newAtomsOnlyFilter") != null) {
      newAtomsOnly = Boolean.parseBoolean(p.getProperty("newAtomsOnlyFilter"));
    }
    if (p.getProperty("filterQueryType") != null) {
      filterQueryType = QueryType.valueOf(QueryType.class,
          String.valueOf(p.getProperty("filterQueryType")));
    }
    if (p.getProperty("filterQuery") != null) {
      filterQuery = String.valueOf(p.getProperty("filterQuery"));
    }
    if (p.getProperty("makeDemotions") != null) {
      makeDemotions = Boolean.parseBoolean(p.getProperty("makeDemotions"));
    }
    if (p.getProperty("changeStatus") != null) {
      changeStatus = Boolean.parseBoolean(p.getProperty("changeStatus"));
    }
    if (p.getProperty("mergeSet") != null) {
      mergeSet = String.valueOf(p.getProperty("mergeSet"));
    }
  }

  /* see superclass */
  @Override
  public List<AlgorithmParameter> getParameters() {
    final List<AlgorithmParameter> params = super.getParameters();

    // Query Type (only support JQL and SQL)
    AlgorithmParameter param = new AlgorithmParameterJpa("Query Type",
        "queryType", "The language the query is written in", "e.g. JQL", 200,
        AlgorithmParameter.Type.ENUM, QueryType.JQL.toString());
    param.setPossibleValues(
        Arrays.asList(QueryType.JQL.toString(), QueryType.SQL.toString()));
    params.add(param);

    // Query
    param = new AlgorithmParameterJpa("Query", "query",
        "A query to perform action only on objects that meet the criteria",
        "e.g. SELECT a.id, b.id FROM AtomJpa a, AtomJpa b ...", 4000,
        AlgorithmParameter.Type.TEXT, "");
    params.add(param);

    // Integrity check names
    param = new AlgorithmParameterJpa("Integrity Checks", "checkNames",
        "The names of the integrity checks to run", "e.g. MGV_B", 200,
        AlgorithmParameter.Type.MULTI, "");

    List<String> validationChecks = new ArrayList<>();
    for (final KeyValuePair validationCheck : getValidationCheckNames()
        .getKeyValuePairs()) {
      // Add handler Name to ENUM list
      validationChecks.add(validationCheck.getKey());
    }
    param.setPossibleValues(validationChecks);
    params.add(param);

    // New atoms only filter
    param = new AlgorithmParameterJpa("New Atoms Only", "newAtomsOnlyFilter",
        "Restrict to new atoms only?", "e.g. true", 5,
        AlgorithmParameter.Type.BOOLEAN, "false");
    params.add(param);

    // filter query type
    param = new AlgorithmParameterJpa("Filter Query Type", "filterQueryType",
        "The language the filter query is written in", "e.g. JQL", 200,
        AlgorithmParameter.Type.ENUM, "");
    param.setPossibleValues(EnumSet.allOf(QueryType.class).stream()
        .map(e -> e.toString()).collect(Collectors.toList()));
    param.getPossibleValues().remove("");
    params.add(param);

    // filter query
    param = new AlgorithmParameterJpa("Filter Query", "filterQuery",
        "A filter query to further restrict the objects to run the merge on",
        "e.g. query in format of the query type", 4000,
        AlgorithmParameter.Type.TEXT, "");
    params.add(param);

    // make demotions
    param = new AlgorithmParameterJpa("Make Demotions", "makeDemotions",
        "Make demotions for failed merges?", "e.g. true", 5,
        AlgorithmParameter.Type.BOOLEAN, "false");
    params.add(param);

    // change status
    param = new AlgorithmParameterJpa("Change Status", "changeStatus",
        "Change status when performing merges?", "e.g. true", 5,
        AlgorithmParameter.Type.BOOLEAN, "false");
    params.add(param);

    // mergeSet
    param = new AlgorithmParameterJpa("Merge Set", "mergeSet",
        "The merge set to perform the merges on", "e.g. NCI-SY", 10,
        AlgorithmParameter.Type.STRING, "");
    params.add(param);

    return params;
  }
}
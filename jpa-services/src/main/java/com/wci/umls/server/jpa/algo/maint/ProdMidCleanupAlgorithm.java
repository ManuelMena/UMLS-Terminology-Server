/*
 *    Copyright 2015 West Coast Informatics, LLC
 */
package com.wci.umls.server.jpa.algo.maint;

import java.util.ArrayList;
import java.util.List;
import java.util.Properties;
import java.util.UUID;

import com.wci.umls.server.AlgorithmParameter;
import com.wci.umls.server.ValidationResult;
import com.wci.umls.server.jpa.ValidationResultJpa;
import com.wci.umls.server.jpa.algo.AbstractInsertMaintReleaseAlgorithm;
import com.wci.umls.server.jpa.algo.RemoveTerminologyAlgorithm;
import com.wci.umls.server.model.meta.Terminology;

/**
 * Implementation of an algorithm to run prod mid cleanup
 */
public class ProdMidCleanupAlgorithm
    extends AbstractInsertMaintReleaseAlgorithm {

  /**
   * Instantiates an empty {@link ProdMidCleanupAlgorithm}.
   * @throws Exception if anything goes wrong
   */
  public ProdMidCleanupAlgorithm() throws Exception {
    super();
    setActivityId(UUID.randomUUID().toString());
    setWorkId("PRODMIDCLEANUP");
    setLastModifiedBy("admin");
  }

  /**
   * Check preconditions.
   *
   * @return the validation result
   * @throws Exception the exception
   */
  /* see superclass */
  @Override
  public ValidationResult checkPreconditions() throws Exception {

    ValidationResult validationResult = new ValidationResultJpa();

    if (getProject() == null) {
      throw new Exception("ProdMid Cleanup requires a project to be set");
    }

    return validationResult;
  }

  /**
   * Compute.
   *
   * @throws Exception the exception
   */
  /* see superclass */
  @Override
  public void compute() throws Exception {
    logInfo("Starting PRODMIDCLEANUP");

    // No molecular actions will be generated by this algorithm
    setMolecularActionFlag(false);

    try {

      logInfo(
          "[ProdMid Cleanup] Removing contents for non-current terminologies.");
      commitClearBegin();

      // Find all non-current terminologies
      List<Terminology> nonCurrentTerminologies = new ArrayList<>();
      for (final Terminology terminology : getTerminologies().getObjects()) {
        if (!terminology.isCurrent()) {
          nonCurrentTerminologies.add(terminology);
        }
      }

      setSteps(nonCurrentTerminologies.size());

      // For each non-current terminology, run removeTerminologies on it (keep
      // the terminology itself for tracking purposes).
      for (final Terminology nonCurrentTerminology : nonCurrentTerminologies) {
        final RemoveTerminologyAlgorithm algo =
            new RemoveTerminologyAlgorithm();
        try {
          logInfo("  Removing content associated with "
              + nonCurrentTerminology.getTerminology() + "/"
              + nonCurrentTerminology.getVersion());

          algo.setLastModifiedBy(getLastModifiedBy());
          algo.setTerminology(nonCurrentTerminology.getTerminology());
          algo.setVersion(nonCurrentTerminology.getVersion());
          algo.setKeepTerminology(true);
          algo.setProject(getProject());
          algo.compute();
          algo.close();

        } catch (Exception e) {
          logError("Unexpected problem - " + e.getMessage());
          algo.rollback();
          algo.close();
          throw e;
        }

        // Update the progress
        updateProgress();
      }

      commitClearBegin();

      logInfo("[ProdMid Cleanup] Removed content for " + getSteps()
          + " non-current terminologies.");

      logInfo("  project = " + getProject().getId());
      logInfo("  workId = " + getWorkId());
      logInfo("  activityId = " + getActivityId());
      logInfo("  user  = " + getLastModifiedBy());
      logInfo("Finished PRODMIDCLEANUP");

    } catch (

    Exception e) {
      logError("Unexpected problem - " + e.getMessage());
      throw e;
    }

  }

  /**
   * Reset.
   *
   * @throws Exception the exception
   */
  /* see superclass */
  @Override
  public void reset() throws Exception {
    // n/a - No reset
  }

  /* see superclass */
  @Override
  public void checkProperties(Properties p) throws Exception {
    // n/a
  }

  /* see superclass */
  @Override
  public void setProperties(Properties p) throws Exception {
    // n/a
  }

  /**
   * Returns the parameters.
   *
   * @return the parameters
   */
  /* see superclass */
  @Override
  public List<AlgorithmParameter> getParameters() {
    final List<AlgorithmParameter> params = super.getParameters();
    return params;
  }

  /* see superclass */
  @Override
  public String getDescription() {
    return "Removes contents for non-current terminologies";
  }

}
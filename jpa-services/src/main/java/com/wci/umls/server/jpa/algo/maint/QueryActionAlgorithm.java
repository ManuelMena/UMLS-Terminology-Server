/*
 *    Copyright 2015 West Coast Informatics, LLC
 */
package com.wci.umls.server.jpa.algo.maint;

import java.util.Arrays;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.UUID;
import java.util.stream.Collectors;

import com.wci.umls.server.AlgorithmParameter;
import com.wci.umls.server.ValidationResult;
import com.wci.umls.server.helpers.QueryType;
import com.wci.umls.server.jpa.AlgorithmParameterJpa;
import com.wci.umls.server.jpa.ValidationResultJpa;
import com.wci.umls.server.jpa.algo.AbstractSourceInsertionAlgorithm;
import com.wci.umls.server.jpa.content.AtomJpa;
import com.wci.umls.server.jpa.content.AtomRelationshipJpa;
import com.wci.umls.server.jpa.content.AttributeJpa;
import com.wci.umls.server.jpa.content.ConceptJpa;
import com.wci.umls.server.jpa.content.SemanticTypeComponentJpa;
import com.wci.umls.server.model.content.Atom;
import com.wci.umls.server.model.content.AtomClass;
import com.wci.umls.server.model.content.AtomRelationship;
import com.wci.umls.server.model.content.Attribute;
import com.wci.umls.server.model.content.Code;
import com.wci.umls.server.model.content.Component;
import com.wci.umls.server.model.content.Concept;
import com.wci.umls.server.model.content.Descriptor;
import com.wci.umls.server.model.content.SemanticTypeComponent;
import com.wci.umls.server.model.meta.IdType;

/**
 * Implementation of an algorithm to execute an action based on a user-defined
 * query.
 */
public class QueryActionAlgorithm extends AbstractSourceInsertionAlgorithm {

  /** The object type. */
  private IdType objectType;

  /** The object type class. */
  private Class<? extends Component> objectTypeClass;

  /** The query type. */
  private QueryType queryType;

  /** The query. */
  private String query;

  /** The action. */
  private String action;

  /** The successful actions. */
  private int successfulActions;

  /** The unsuccessful actions. */
  private int unsuccessfulActions;

  /**
   * Instantiates an empty {@link QueryActionAlgorithm}.
   * @throws Exception if anything goes wrong
   */
  public QueryActionAlgorithm() throws Exception {
    super();
    setActivityId(UUID.randomUUID().toString());
    setWorkId("QUERYACTION");
    setLastModifiedBy("admin");
  }

  /**
   * Check preconditions.
   *
   * @return the validation result
   * @throws Exception the exception
   */
  /* see superclass */
  @Override
  public ValidationResult checkPreconditions() throws Exception {

    ValidationResult validationResult = new ValidationResultJpa();

    if (getProject() == null) {
      throw new Exception(
          "Query Action algorithms requires a project to be set");
    }

    // If the action is approve, the objectType must be a concept
    if (action.equals("Approve") && objectType.equals(IdType.CONCEPT)) {
      throw new Exception(
          "Approve actions can only be performed on concept - current selected object type is: "
              + objectType);
    }

    return validationResult;
  }

  /**
   * Compute.
   *
   * @throws Exception the exception
   */
  /* see superclass */
  @Override
  public void compute() throws Exception {
    logInfo("Starting QUERYACTION: " + action + " " + objectType);

    // No Molecular actions will be generated by this algorithm
    setMolecularActionFlag(false);

    logInfo("[QueryAction]: " + action + " " + objectType + " for results of "
        + queryType.toString() + " query: " + query);

    // Count number of actions successfully and unsuccessfully performed
    successfulActions = 0;
    unsuccessfulActions = 0;

    // Generate parameters to pass into query executions
    Map<String, String> params = new HashMap<>();
    params.put("terminology", this.getTerminology());
    params.put("version", this.getVersion());
    params.put("projectTerminology", getProject().getTerminology());
    params.put("projectVersion", getProject().getVersion());

    // Execute query to get component Ids
    List<Long[]> componentIds = executeSingleComponentIdQuery(query, queryType,
        params, objectTypeClass);

    setSteps(componentIds.size());

    for (Long[] componentId : componentIds) {
      // Load the component
      Component component = getComponent(componentId[0], objectTypeClass);

      // Handle approve actions
      if (action.equals("Approve")) {
        // approve(component);
      }
      // Handle unapprove actions
      else if (action.equals("Unapprove")) {
        // unapprove(component);
      }
      // Handle Make Publishable actions
      else if (action.equals("Make Publishable")) {
        changePublishable(component, true);
      }
      // Handle Make Unpublishable actions
      else if (action.equals("Make Unpublishable")) {
        changePublishable(component, false);
      }
      // Handle Remove actions
      else if (action.equals("Remove")) {
        remove(component, params);
      }

      // Update the progress
      updateProgress();
    }

    commitClearBegin();

    logInfo("[QueryAction] " + successfulActions + " " + action
        + " " + objectType + " actions successfully performed.");
    logInfo("[QueryAction] " + unsuccessfulActions + " attempted " + action
        + " " + objectType + " actions were unsuccessful.");

    logInfo("  project = " + getProject().getId());
    logInfo("  workId = " + getWorkId());
    logInfo("  activityId = " + getActivityId());
    logInfo("  user  = " + getLastModifiedBy());
    logInfo("Finished QUERYACTION: " + objectType + " " + action);

  }

  private void remove(Component component, Map<String, String> params)
    throws Exception {

    // Handle atom removal
    if (component instanceof Atom) {
      removeAtomFromContainer(component, Code.class, params);
      removeAtomFromContainer(component, Concept.class, params);
      removeAtomFromContainer(component, Descriptor.class, params);

      removeAtom(component.getId());
      successfulActions++;
    }

    // Handle Semantic Types removal
    else if (component instanceof SemanticTypeComponent) {
      removeComponentFromConcept(component, params);

      removeSemanticTypeComponent(component.getId());
      successfulActions++;
    }

    // Handle Attribute removal
    else if (component instanceof Attribute) {
      removeComponentFromConcept(component, params);

      removeAttribute(component.getId());
      successfulActions++;
    }

    // Handle Atom Relationship removal
    else if (component instanceof AtomRelationship) {
      AtomRelationship atomRelationship = (AtomRelationship) component;

      Atom fromAtom = atomRelationship.getFrom();
      Atom toAtom = atomRelationship.getTo();
      AtomRelationship inverseAtomRelationship =
          (AtomRelationship) getInverseRelationship(atomRelationship);

      fromAtom.getRelationships().remove(atomRelationship);
      toAtom.getRelationships().remove(inverseAtomRelationship);

      updateAtom(fromAtom);
      updateAtom(toAtom);

      removeRelationship(atomRelationship.getId(), AtomRelationship.class);
      removeRelationship(inverseAtomRelationship.getId(),
          AtomRelationship.class);
      successfulActions++;
    }

    // Handle Concept removal???
    else if (component instanceof Concept) {
      removeConcept(component.getId());
      successfulActions++;
    }
  }

  /**
   * Removes the component from concept.
   *
   * @param component the component
   * @param params the params
   * @throws Exception the exception
   */
  private void removeComponentFromConcept(Component component,
    Map<String, String> params) throws Exception {

    String objectName = null;
    if (component instanceof SemanticTypeComponent) {
      objectName = "semanticTypes";
    }
    else if (component instanceof Attribute) {
      objectName = "attributes";
    } else {
      throw new Exception("Unhandled component type: " + component);
    }

    String conceptQuery = "SELECT c.id FROM ConceptJpa c JOIN c." + objectName
        + " o " + "WHERE o.id="+component.getId().toString();
    List<Long[]> conceptIds = executeSingleComponentIdQuery(conceptQuery,
        QueryType.JQL, params, Concept.class);
    for (Long[] conceptId : conceptIds) {
      Concept concept = getConcept(conceptId[0]);
      if (component instanceof SemanticTypeComponent) {
        concept.getSemanticTypes().remove(component);
      }
      else if (component instanceof Attribute) {
        concept.getAttributes().remove(component);
      }      

      updateConcept(concept);
    }
  }

  private void removeAtomFromContainer(Component atom,
    Class<? extends AtomClass> clazz, Map<String, String> params)
    throws Exception {
    String containerQuery = "SELECT c.id FROM " + clazz.getSimpleName()
        + "Jpa c JOIN c.atoms a " + "WHERE a.id=" + atom.getId().toString();
    List<Long[]> containerIds = executeSingleComponentIdQuery(containerQuery,
        QueryType.JQL, params, clazz);
    for (Long[] containerId : containerIds) {
      AtomClass atomClass = getComponent(containerId[0], clazz);
      atomClass.getAtoms().remove(atom);
      updateComponent(atomClass);
    }
  }

  private void changePublishable(Component component, boolean newPublishable)
    throws Exception {
    if (component.isPublishable() != newPublishable) {
      component.setPublishable(newPublishable);
      updateComponent(component);
    }

    successfulActions++;
  }

  /**
   * Determine class.
   *
   * @return the class
   */
  private Class<? extends Component> determineClass() {

    if (objectType.equals(IdType.CONCEPT)) {
      return ConceptJpa.class;
    } else if (objectType.equals(IdType.RELATIONSHIP)) {
      // NOTE: all relationships are assumed to be AtomRelationships.
      return AtomRelationshipJpa.class;
    } else if (objectType.equals(IdType.SEMANTIC_TYPE)) {
      return SemanticTypeComponentJpa.class;
    } else if (objectType.equals(IdType.ATTRIBUTE)) {
      return AttributeJpa.class;
    } else if (objectType.equals(IdType.ATOM)) {
      return AtomJpa.class;
    } else
      return null;
  }

  /**
   * Reset.
   *
   * @throws Exception the exception
   */
  /* see superclass */
  @Override
  public void reset() throws Exception {
    // n/a - No reset
  }

  /* see superclass */
  @Override
  public void checkProperties(Properties p) throws Exception {
    checkRequiredProperties(new String[] {
        "queryType", "query", "objectType", "action"
    }, p);
  }

  /* see superclass */
  @Override
  public void setProperties(Properties p) throws Exception {

    if (p.getProperty("objectType") != null) {
      objectType = IdType.valueOf(String.valueOf(p.getProperty("objectType")));
      objectTypeClass = determineClass();
    }
    if (p.getProperty("action") != null) {
      action = String.valueOf(p.getProperty("action"));
    }
    if (p.getProperty("queryType") != null) {
      queryType = QueryType.valueOf(QueryType.class,
          String.valueOf(p.getProperty("queryType")));
    }
    if (p.getProperty("query") != null) {
      query = String.valueOf(p.getProperty("query"));
    }

  }

  /**
   * Returns the parameters.
   *
   * @return the parameters
   */
  /* see superclass */
  @Override
  public List<AlgorithmParameter> getParameters() {
    final List<AlgorithmParameter> params = super.getParameters();
    AlgorithmParameter param = new AlgorithmParameterJpa("ObjectType",
        "objectType", "Type of object an action will be performed on",
        "e.g. Concept", 200, AlgorithmParameter.Type.ENUM, "");
    param.setPossibleValues(Arrays.asList(IdType.CONCEPT.toString(),
        IdType.RELATIONSHIP.toString(), IdType.SEMANTIC_TYPE.toString(),
        IdType.ATTRIBUTE.toString(), IdType.ATOM.toString()));
    params.add(param);

    param = new AlgorithmParameterJpa("Action", "action",
        "An action to perform on the specified object type", "e.g. Approve",
        200, AlgorithmParameter.Type.ENUM, "");
    param.setPossibleValues(Arrays.asList("Remove", "Make Publishable",
        "Make Unpublishable", "Approve", "Unapprove"));
    params.add(param);

    param = new AlgorithmParameterJpa("QueryType", "queryType",
        "The language the query is written in", "e.g. JQL", 200,
        AlgorithmParameter.Type.ENUM, "");
    param.setPossibleValues(EnumSet.allOf(QueryType.class).stream()
        .map(e -> e.toString()).collect(Collectors.toList()));
    params.add(param);

    param = new AlgorithmParameterJpa("Query", "query",
        "A query to perform action only on objects that meet the criteria",
        "e.g. query in format of the query type", 4000,
        AlgorithmParameter.Type.TEXT, "");
    params.add(param);

    return params;
  }

}
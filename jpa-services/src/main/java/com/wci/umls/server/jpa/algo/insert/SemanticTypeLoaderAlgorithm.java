/*
 *    Copyright 2015 West Coast Informatics, LLC
 */
package com.wci.umls.server.jpa.algo.insert;

import java.io.File;
import java.util.List;
import java.util.Properties;
import java.util.UUID;

import com.wci.umls.server.AlgorithmParameter;
import com.wci.umls.server.ValidationResult;
import com.wci.umls.server.helpers.Branch;
import com.wci.umls.server.helpers.CancelException;
import com.wci.umls.server.helpers.ConfigUtility;
import com.wci.umls.server.helpers.FieldedStringTokenizer;
import com.wci.umls.server.jpa.ValidationResultJpa;
import com.wci.umls.server.jpa.algo.AbstractSourceLoaderAlgorithm;
import com.wci.umls.server.jpa.content.ConceptJpa;
import com.wci.umls.server.jpa.content.SemanticTypeComponentJpa;
import com.wci.umls.server.model.content.Atom;
import com.wci.umls.server.model.content.AtomClass;
import com.wci.umls.server.model.content.Concept;
import com.wci.umls.server.model.content.SemanticTypeComponent;
import com.wci.umls.server.model.meta.Terminology;
import com.wci.umls.server.services.RootService;
import com.wci.umls.server.services.handlers.ComputePreferredNameHandler;
import com.wci.umls.server.services.handlers.IdentifierAssignmentHandler;
import com.wci.umls.server.services.handlers.SearchHandler;

/**
 * Implementation of an algorithm to import semantic types.
 */
public class SemanticTypeLoaderAlgorithm extends AbstractSourceLoaderAlgorithm {

  /** The full directory where the src files are. */
  private File srcDirFile = null;

  /** The previous progress. */
  private int previousProgress;

  /** The steps. */
  private int steps;

  /** The steps completed. */
  private int stepsCompleted;

  /**
   * Instantiates an empty {@link SemanticTypeLoaderAlgorithm}.
   * @throws Exception if anything goes wrong
   */
  public SemanticTypeLoaderAlgorithm() throws Exception {
    super();
    setActivityId(UUID.randomUUID().toString());
    setWorkId("SEMANTICTYPELOADER");
    setLastModifiedBy("admin");
  }

  /**
   * Check preconditions.
   *
   * @return the validation result
   * @throws Exception the exception
   */
  /* see superclass */
  @Override
  public ValidationResult checkPreconditions() throws Exception {

    ValidationResult validationResult = new ValidationResultJpa();

    if (getProject() == null) {
      throw new Exception("Semantic Type Loading requires a project to be set");
    }

    // Check the input directories

    String srcFullPath =
        ConfigUtility.getConfigProperties().getProperty("source.data.dir")
            + File.separator + getProcess().getInputPath();

    srcDirFile = new File(srcFullPath);
    if (!srcDirFile.exists()) {
      throw new Exception("Specified input directory does not exist");
    }

    return validationResult;
  }

  /**
   * Compute.
   *
   * @throws Exception the exception
   */
  /* see superclass */
  @Override
  public void compute() throws Exception {
    logInfo("Starting SEMANTICTYPELOADING");

    // No molecular actions will be generated by this algorithm
    setMolecularActionFlag(false);

    // Set up the handler for identifier assignment
    final IdentifierAssignmentHandler handler =
        newIdentifierAssignmentHandler(getProject().getTerminology());
    final SearchHandler searchHandler = getSearchHandler(ConfigUtility.DEFAULT);
    final ComputePreferredNameHandler prefNameHandler =
        getComputePreferredNameHandler(getProject().getTerminology());
    handler.setTransactionPerOperation(false);
    handler.beginTransaction();

    // Count number of added and updated Semantic Types, for logging
    int addCount = 0;
    int updateCount = 0;

    try {

      previousProgress = 0;
      stepsCompleted = 0;

      logInfo("[SemanticTypeLoader] Checking for new/updated Semantic Types");

      //
      // Load the attributes.src file, only keeping SEMANTIC_TYPE lines.
      //
      List<String> lines = loadFileIntoStringList(srcDirFile, "attributes.src",
          "(([a-zA-Z0-9]+?)\\|){3}(SEMANTIC_TYPE\\|){1}(.*)", null);

      // Set the number of steps to the number of atoms to be processed
      steps = lines.size();

      String fields[] = new String[14];

      for (String line : lines) {

        // Check for a cancelled call once every 100 relationships (doing it
        // every time
        // makes things too slow)
        if (stepsCompleted % 100 == 0 && isCancelled()) {
          throw new CancelException("Cancelled");
        }

        FieldedStringTokenizer.split(line, "|", 14, fields);

        // Fields:
        // 0 source_attribute_id
        // 1 sg_id
        // 2 attribute_level
        // 3 attribute_name
        // 4 attribute_value
        // 5 source
        // 6 status
        // 7 tobereleased
        // 8 released
        // 9 suppressible
        // 10 sg_type_1
        // 11 sg_qualifier_1
        // 12 source_atui
        // 13 hashcode

        // e.g.
        // 49|C47666|S|Chemical_Formula|C19H32N2O5.C4H11N|NCI_2016_05E|R|Y|N|N|SOURCE_CUI|NCI_2016_05E||875b4a03f8dedd9de05d6e9e4a440401|

        // Load the referenced atom, or preferred atom of atomClass object
        Atom atom = null;
        Class<?> containingObjectClass = lookupClass(fields[10]);
        
        //TODO question: terminology in fields[5] vs. fields[11]
        Terminology terminology = getCachedTerminology(fields[5]);
        if (terminology == null) {
          logWarn("Warning - terminology not found: " + fields[5]
              + ". Could not process the following line:\n\t" + line);
          updateProgress();
          logAndCommit("[SemanticType Loader] SemanticType lines processed ",
              stepsCompleted, RootService.logCt, RootService.commitCt);
          continue;
        }

        // atom case
        if (Atom.class.isAssignableFrom(containingObjectClass)) {
          // Load the containing object
          final String atomAltId = fields[1];

          // TODO confirm - getting atom associated with terminology specified in file
          Long atomId = getId(containingObjectClass, atomAltId,
              terminology.getTerminology());
          atom = atomId == null ? null : getAtom(atomId);

          if (atom == null) {
            logWarn("Warning - atom not found for AUI: " + atomAltId
                + ". Could not process the following line:\n\t" + line);
            updateProgress();
            logAndCommit("[SemanticType Loader] SemanticTypes processed ",
                stepsCompleted, RootService.logCt, RootService.commitCt);
            continue;
          }

        }

        // atom class case
        else {
          // TODO confirm - getting atomClass associated with terminology
          // specified in file
          AtomClass atomClass = (AtomClass) getComponent(fields[1],
              terminology.getTerminology(), terminology.getVersion(),
              Branch.ROOT, lookupClass(fields[10]));

          // compute preferred atom
          List<Atom> atoms =
              prefNameHandler.sortAtoms(atomClass.getAtoms(), getPrecedenceList(
                  getProject().getTerminology(), getProject().getVersion()));
          atom = atoms.get(0);

        }

        // TODO confirm - getting Concept associated with PROJECT terminology
        // Get the concept associated with the loaded atom, or preferred atom of
        // loaded atomClass Object
        Concept concept = null;
        List<ConceptJpa> concepts = searchHandler.getQueryResults(
            getProject().getTerminology(), getProject().getVersion(),
            Branch.ROOT, "atoms.id:" + atom.getId(), null, ConceptJpa.class,
            null, new int[1], getEntityManager());
        if (concepts.size() != 1) {
          throw new Exception("Unexpected number of concepts: "
              + concepts.size() + ", for atom: " + atom.getId());
        }
        concept = concepts.get(0);

        // If concept has a semantic type already matching this value, move on
        // otherwise add a new semantic type.
        boolean componentContainsSty = false;
        for (SemanticTypeComponent sty : concept.getSemanticTypes()) {
          if (sty.getSemanticType().equals("fields[4]")) {
            componentContainsSty = true;
            break;
          }
        }

        if (!componentContainsSty) {
          SemanticTypeComponent newSty = new SemanticTypeComponentJpa();
          newSty.setBranch(Branch.ROOT);
          newSty.setName(fields[4]);
          newSty.setObsolete(false);
          newSty.setPublishable(fields[7].equals("Y"));
          newSty.setPublished(fields[8].equals("Y"));
          newSty.setSemanticType(fields[4]);
          newSty.setSuppressible(fields[9].equals("Y"));
          newSty.setTerminology(terminology.getTerminology());
          //TODO question: termId?
          newSty.setTerminologyId("");
          newSty.setVersion(terminology.getVersion());
          newSty.setWorkflowStatus(lookupWorkflowStatus(fields[6]));

          newSty = addSemanticTypeComponent(newSty, concept);
          concept.getSemanticTypes().add(newSty);
          updateConcept(concept);

          addCount++;
        }

        // Update the progress
        updateProgress();

        logAndCommit("[Semantic Type Loader] Semantic Types processed ",
            stepsCompleted, RootService.logCt, RootService.commitCt);
        handler.logAndCommit(
            "[Semantic Type Loader] Semantic Type identities processed ",
            stepsCompleted, RootService.logCt, RootService.commitCt);

      }

      commitClearBegin();
      handler.commitClearBegin();

      logInfo(
          "[SemanticTypeLoader] Added " + addCount + " new Semantic Types.");
      logInfo("[SemanticTypeLoader] Updated " + updateCount
          + " existing Semantic Types.");

      logInfo("  project = " + getProject().getId());
      logInfo("  workId = " + getWorkId());
      logInfo("  activityId = " + getActivityId());
      logInfo("  user  = " + getLastModifiedBy());
      logInfo("Finished SEMANTICTYPELOADING");

    } catch (

    Exception e) {
      logError("Unexpected problem - " + e.getMessage());
      throw e;
    }

  }

  /**
   * Reset.
   *
   * @throws Exception the exception
   */
  /* see superclass */
  @Override
  public void reset() throws Exception {
    // n/a - No reset
  }

  /**
   * Update progress.
   *
   * @throws Exception the exception
   */
  public void updateProgress() throws Exception {
    stepsCompleted++;
    int currentProgress = (int) ((100.0 * stepsCompleted / steps));
    if (currentProgress > previousProgress) {
      fireProgressEvent(currentProgress,
          "SEMANTICTYPELOADING progress: " + currentProgress + "%");
      previousProgress = currentProgress;
    }
  }

  /**
   * Sets the properties.
   *
   * @param p the properties
   * @throws Exception the exception
   */
  /* see superclass */
  @Override
  public void setProperties(Properties p) throws Exception {
    checkRequiredProperties(new String[] {
        // TODO - handle problem with config.properties needing properties
    }, p);

  }

  /**
   * Returns the parameters.
   *
   * @return the parameters
   */
  /* see superclass */
  @Override
  public List<AlgorithmParameter> getParameters() {
    final List<AlgorithmParameter> params = super.getParameters();

    return params;
  }

}
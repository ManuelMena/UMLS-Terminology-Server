/*
 *    Copyright 2015 West Coast Informatics, LLC
 */
package com.wci.umls.server.jpa.algo.insert;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.UUID;

import com.wci.umls.server.AlgorithmParameter;
import com.wci.umls.server.ValidationResult;
import com.wci.umls.server.helpers.QueryType;
import com.wci.umls.server.jpa.AlgorithmParameterJpa;
import com.wci.umls.server.jpa.ValidationResultJpa;
import com.wci.umls.server.jpa.algo.AbstractSourceInsertionAlgorithm;
import com.wci.umls.server.model.content.Atom;
import com.wci.umls.server.model.content.AtomRelationship;
import com.wci.umls.server.model.workflow.WorkflowStatus;

/**
 * Implementation of an algorithm to remove demotions from atoms matching
 * criteria.
 */
public class SafeReplaceAlgorithm extends AbstractSourceInsertionAlgorithm {

  /** The string class id flag. */
  private Boolean stringClassId = null;

  /** The lexical class id flag. */
  private Boolean lexicalClassId = null;

  /** The code id flag. */
  private Boolean codeId = null;

  /** The concept id flag. */
  private Boolean conceptId = null;

  /** The descriptor id flag. */
  private Boolean descriptorId = null;

  /**
   * Instantiates an empty {@link SafeReplaceAlgorithm}.
   * @throws Exception if anything goes wrong
   */
  public SafeReplaceAlgorithm() throws Exception {
    super();
    setActivityId(UUID.randomUUID().toString());
    setWorkId("SAFEREPLACE");
    setLastModifiedBy("admin");
  }

  /**
   * Check preconditions.
   *
   * @return the validation result
   * @throws Exception the exception
   */
  /* see superclass */
  @Override
  public ValidationResult checkPreconditions() throws Exception {

    ValidationResult validationResult = new ValidationResultJpa();

    if (getProject() == null) {
      throw new Exception("Safe Replace requires a project to be set");
    }

    return validationResult;
  }

  /**
   * Compute.
   *
   * @throws Exception the exception
   */
  /* see superclass */
  @Override
  public void compute() throws Exception {
    logInfo("Starting SAFEREPLACE");

    // Molecular actions will be generated by this algorithm
    // TODO - molecular actions?
    setMolecularActionFlag(true);

    // Find all atoms pairs that satisfy the specified matching criteria and are
    // in the same [project Terminology] concept

    // Generate query string
     String query =
        "SELECT a1.id, a2.id "
            + "FROM ConceptJpa c1 JOIN c1.atoms a1, ConceptJpa c2 JOIN c2.atoms a2 "
            + "WHERE c1.id = c2.id " + "AND NOT a1.id = a2.id "
            + "AND c1.terminology=:projectTerminology AND c1.version=:projectVersion "
            + (stringClassId ? "AND a1.stringClassId = a2.stringClassId " : "")
            + (lexicalClassId ? "AND a1.lexicalClassId = a2.lexicalClassId "
                : "")
            + (conceptId ? "AND a1.conceptId = a2.conceptId " : "")
            + (codeId ? "AND a1.codeId = a2.codeId " : "")
            + (descriptorId ? "AND a1.descriptorId = a2.descriptorId " : "");

    // Generate parameters to pass into query executions
    Map<String, String> params = new HashMap<>();
    params.put("projectTerminology", getProject().getTerminology());
    params.put("projectVersion", getProject().getVersion());

    final List<Long[]> atomIdPairArray =
        executeAtomIdPairQuery(query, QueryType.JQL, params);

    // Create map <Long,Set<Long>)
    // Key=fromAtomId,
    // Value=set of all toAtomIds associated with fromAtomId
    final Map<Long, Set<Long>> atomPairMap = new HashMap<>();
    for (Long[] atomIdPair : atomIdPairArray) {
      Set<Long> associatedAtoms = atomPairMap.get(atomIdPair[0]);
      if (associatedAtoms == null || associatedAtoms.isEmpty()) {
        associatedAtoms = new HashSet<>();
      }
      associatedAtoms.add(atomIdPair[1]);
      atomPairMap.put(atomIdPair[0], associatedAtoms);
    }

    setSteps(atomPairMap.size());
    
    logInfo("[Safe Replace] removing demotions");

    // If an atom has a demotion to any of its associated atoms, remove it
    for (Map.Entry<Long, Set<Long>> entry : atomPairMap.entrySet()) {
      Long atomId = entry.getKey();
      Set<Long> associatedAtomIds = entry.getValue();

      final Atom atom = getAtom(atomId);
      final Set<Long> removeRelationshipIds = new HashSet<>();

      for (AtomRelationship rel : atom.getRelationships()) {
        if (rel.getWorkflowStatus().equals(WorkflowStatus.DEMOTION)
            && associatedAtomIds.contains(rel.getTo().getId())) {

          // TODO - if molecular actions, create removeDemotionMolecularAction?
          // Or find addDemotion, and undo it (seems overkill)

          // Remove the demotion from the atom
          atom.getRelationships().remove(rel);

          // Save the relationship Id, to remove later
          removeRelationshipIds.add(rel.getId());
        }
      }

      // If any demotions are removed from the atom, update the atom, and
      // delete the demotions
      if (removeRelationshipIds.size() > 0) {
        updateAtom(atom);
      }
      // And delete the demotions
      for (Long relId : removeRelationshipIds) {
        removeRelationship(relId, AtomRelationship.class);
        // Note: Don't need to handle the inverse demotion - the reverse
        // atomPair will also be included in the query results
      }
      // Update the progress
      updateProgress();
    }

    commitClearBegin();

    logInfo("  project = " + getProject().getId());
    logInfo("  workId = " + getWorkId());
    logInfo("  activityId = " + getActivityId());
    logInfo("  user  = " + getLastModifiedBy());
    logInfo("Finished SAFEREPLACE");

  }

  /**
   * Reset.
   *
   * @throws Exception the exception
   */
  /* see superclass */
  @Override
  public void reset() throws Exception {
    // n/a - No reset
  }

  /* see superclass */
  @Override
  public void checkProperties(Properties p) throws Exception {
    // n/a
  }

  /* see superclass */
  @Override
  public void setProperties(Properties p) throws Exception {
    if (p.getProperty("stringClassId") != null) {
      stringClassId = Boolean.parseBoolean(p.getProperty("stringClassId"));
    }
    if (p.getProperty("lexicalClassId") != null) {
      lexicalClassId = Boolean.parseBoolean(p.getProperty("lexicalClassId"));
    }
    if (p.getProperty("codeId") != null) {
      codeId = Boolean.parseBoolean(p.getProperty("codeId"));
    }
    if (p.getProperty("conceptId") != null) {
      conceptId = Boolean.parseBoolean(p.getProperty("conceptId"));
    }
    if (p.getProperty("descriptorId") != null) {
      descriptorId = Boolean.parseBoolean(p.getProperty("descriptorId"));
    }
  }

  /* see superclass */
  @Override
  public List<AlgorithmParameter> getParameters() {
    final List<AlgorithmParameter> params = super.getParameters();

    AlgorithmParameter param = new AlgorithmParameterJpa("String Class Id",
        "stringClassId", "Match atoms by String Class Id?", "e.g. true", 5,
        AlgorithmParameter.Type.BOOLEAN, "false");
    params.add(param);

    param = new AlgorithmParameterJpa("Lexical Class Id", "lexicalClassId",
        "Match atoms by Lexical Class Id?", "e.g. true", 5,
        AlgorithmParameter.Type.BOOLEAN, "false");
    params.add(param);

    param = new AlgorithmParameterJpa("Code Id", "codeId",
        "Match atoms by Code Id?", "e.g. true", 5,
        AlgorithmParameter.Type.BOOLEAN, "false");
    params.add(param);

    param = new AlgorithmParameterJpa("Concept Id", "conceptId",
        "Match atoms by Concept Id?", "e.g. true", 5,
        AlgorithmParameter.Type.BOOLEAN, "false");
    params.add(param);

    param = new AlgorithmParameterJpa("Descriptor Id", "descriptorId",
        "Match atoms by Descriptor Id?", "e.g. true", 5,
        AlgorithmParameter.Type.BOOLEAN, "false");
    params.add(param);

    return params;
  }

}